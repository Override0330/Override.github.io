<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="author" content="Override"><meta name="renderer" content="webkit"><meta name="copyright" content="Override"><meta name="keywords" content="Override0330"><meta name="description" content="null"><meta name="Cache-Control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>Git的使用 · Override's Blog from GitHub</title><link rel="stylesheet" href="/css/style.css?v=2018.7.9"><link rel="stylesheet" href="/css/animation.css?v=2018.7.9"><link rel="icon" href="/img/assets/Myojyafavicon.ico"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><!-- scripts--><script>(function( w ){
  "use strict";
  // rel=preload support test
  if( !w.loadCSS ){
    w.loadCSS = function(){};
  }
  // define on the loadCSS obj
  var rp = loadCSS.relpreload = {};
  // rel=preload feature support test
  // runs once and returns a function for compat purposes
  rp.support = (function(){
    var ret;
    try {
      ret = w.document.createElement( "link" ).relList.supports( "preload" );
    } catch (e) {
      ret = false;
    }
    return function(){
      return ret;
    };
  })();

  // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
  // then change that media back to its intended value on load
  rp.bindMediaToggle = function( link ){
    // remember existing media attr for ultimate state, or default to 'all'
    var finalMedia = link.media || "all";

    function enableStylesheet(){
      link.media = finalMedia;
    }

    // bind load handlers to enable media
    if( link.addEventListener ){
      link.addEventListener( "load", enableStylesheet );
    } else if( link.attachEvent ){
      link.attachEvent( "onload", enableStylesheet );
    }

    // Set rel and non-applicable media type to start an async request
    // note: timeout allows this to happen async to let rendering continue in IE
    setTimeout(function(){
      link.rel = "stylesheet";
      link.media = "only x";
    });
    // also enable media after 3 seconds,
    // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
    setTimeout( enableStylesheet, 3000 );
  };

  // loop through link elements in DOM
  rp.poly = function(){
    // double check this to prevent external calls from running
    if( rp.support() ){
      return;
    }
    var links = w.document.getElementsByTagName( "link" );
    for( var i = 0; i < links.length; i++ ){
      var link = links[ i ];
      // qualify links to those with rel=preload and as=style attrs
      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
        // prevent rerunning on link
        link.setAttribute( "data-loadcss", true );
        // bind listeners to toggle media back
        rp.bindMediaToggle( link );
      }
    }
  };

  // if unsupported, run the polyfill
  if( !rp.support() ){
    // run once at least
    rp.poly();

    // rerun poly on an interval until onload
    var run = w.setInterval( rp.poly, 500 );
    if( w.addEventListener ){
      w.addEventListener( "load", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    } else if( w.attachEvent ){
      w.attachEvent( "onload", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    }
  }


  // commonjs
  if( typeof exports !== "undefined" ){
    exports.loadCSS = loadCSS;
  }
  else {
    w.loadCSS = loadCSS;
  }
}( typeof global !== "undefined" ? global : this ) );</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" defer></script><script src="/js/main.js?v=2018.7.9" defer></script><!-- fancybox--><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script><!-- busuanzi--><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></head><body><section class="profile-close" id="cxo-profile"><div class="profile-avatar"><i class="fa fa-caret-left"></i><img src="/img/assets/Myojya.jpg"></div><!--.profile-saying
  i.fa.fa-comment
  .saying--><div class="cxo-profile-inner"><div class="profile-name">Override</div><div class="profile-signature">CQUPT_RedrockMobileStudent</div><div class="friends"><div>FRIENDS</div><span><a href="//github.com/Sajotim" target="_black">大鸽Sajo的GitHub传送门</a></span></div><div class="read-progress"></div></div></section><header id="cxo-intro" style="height: 70vh;background-image: url(/img/intro/index-bg3.png);"><nav id="cxo-intro-nav"><section><div class="intro-nav-title"><a href="/">Override的GitHub空间OvO</a></div><div class="intro-nav-label-box"><a href="/">主页</a><a href="/about/">关于</a><a href="/archives/">时间轴</a></div><i class="fa fa-bars intro-nav-menu"><div class="intro-nav-drop"><a href="/">主页</a><a href="/about/">关于</a><a href="/archives/">时间轴</a></div></i><div class="clear"></div></section></nav><h1 class="post-title">Git的使用</h1><div class="post-intros"><div class="post-intro-meta"><span class="post-intro-time"><i class="post-intro-calendar fa fa-calendar"></i><span>2019-03-13</span></span></div></div></header><article class="cxo-up" id="cxo-content-outer"><section id="cxo-content-inner"><article class="article-entry" id="post"><p>这篇就算在这一周的学习笔记里吧😆</p>
<p>本文在我的Github上体验不佳,等我换了主题应该会好很多</p>
<p>推荐去简书查看原文</p>
<p>简书地址：<a href="https://www.jianshu.com/p/c5fb9f2dbb75" target="_blank" rel="noopener">https://www.jianshu.com/p/c5fb9f2dbb75</a></p>
<blockquote>
<p>从进入红岩交的第二份作业开始就是使用的Github来上交的，但是一直一直以来，我一直只把Github当做一个云存储来使用，写完代码之后，就add，commit，push，然后结束自己的工作。如果Github只是这么使用的话，有愧于它的名字——分布式版本控制系统。最近终于有时间真正的了解Git的使用，下面是学习完<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000#0" target="_blank" rel="noopener">Git教程-廖雪峰的官方网站</a>之后整理的学习笔记。</p>
</blockquote>
<h2 id="1-Git的由来"><a href="#1-Git的由来" class="headerlink" title="1. Git的由来"></a>1. Git的由来</h2><blockquote>
<p>这个并不是本文的重点，但是还是需要了解一下</p>
</blockquote>
<p>Git的由来不得不提Linux，Linux是一个完全开源的系统，而它的用途我就不再赘述。既然是一个开源的项目，那就需要大家一起来参与开发，当是使用的是BitKeeper(同样是一个代码托管平台，不过是付费的)，而且出于人道主义它对Linux社区是免费的。但是后来由于一些Linux牛人尝试去破解BitKeeper的协议被BitKeeper发现，决定取消linux社区免费的制度。然而Linux的创始人Linus仅仅花了两周用<strong>C语言</strong>就写出了Git来代替了BitKeeper！之后越来越多的开源项目使用Git这个版本控制系统。到了2008年Github网站上线，简单易用速度快的Git更是被大家广泛使用。</p>
<h2 id="2-Git的结构"><a href="#2-Git的结构" class="headerlink" title="2. Git的结构"></a>2. Git的结构</h2><h3 id="2-1-分布式"><a href="#2-1-分布式" class="headerlink" title="2.1 分布式"></a>2.1 分布式</h3><p>上文提到Git是一款分布式版本控制系统，与之相对的是集中式版本控制系统。<br><strong>集中式版本控制系统示意图：</strong><img src="https://upload-images.jianshu.io/upload_images/15366117-2046da2dacadf346.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ20190312-131318@2x.png"><br>集中式意思就是每次工作的时候从服务器拉取最新的版本，然后自己更改完代码后再推送给服务器。工作的时候需要联网。</p>
<blockquote>
<p>从某种意义上来说我之前那样Git使用和集中式没有多大区别233333</p>
</blockquote>
<p><strong>分布式版本控制系统示意图：</strong><br><img src="https://upload-images.jianshu.io/upload_images/15366117-79941c39723e9579.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ20190312-132533@2x.png"><br>在分布式中，代码(仓库)不存放在服务器中，而是存放在某个人的电脑中，你可以获取到自己的电脑中，然后进行更改，最后提交更改。给我的感觉有点像区块链的去中心化。整个工作过程一旦获取了仓库的内容就不需要联网。而远程仓库的存在实际上提供一个桥梁的功能，因为图中的成员A和B处于同一个局域网中，而成员C并不是，所以只能通过远程仓库来进行操作。</p>
<p>到这里可能还是没看的出来这个两者的区别，因为Git还有很重要的分支功能没有介绍（同时也是我之前一直没使用的功能）。</p>
<h3 id="2-2-仓库结构"><a href="#2-2-仓库结构" class="headerlink" title="2.2 仓库结构"></a>2.2 仓库结构</h3><p>和集中式版本控制系统一样，Git也拥有工作区和版本库。但是版本库中加了一个<strong>暂存区</strong>。</p>
<h4 id="2-2-1-工作区"><a href="#2-2-1-工作区" class="headerlink" title="2.2.1 工作区"></a>2.2.1 工作区</h4><p>工作区就是我们电脑本地能看到的文件夹<img src="https://upload-images.jianshu.io/upload_images/15366117-c7eb477359fe17e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ20190312-133633@2x.png"></p>
<blockquote>
<p>.git是一个隐藏文件夹，里面记录这重要的信息，请不要动他</p>
</blockquote>
<h4 id="2-2-2-代码库"><a href="#2-2-2-代码库" class="headerlink" title="2.2.2 代码库"></a>2.2.2 代码库</h4><p>下面引用廖雪峰的图：<img src="https://upload-images.jianshu.io/upload_images/15366117-da255bb8cbef9832.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="0 (1).jpeg"><br>我们常用的add，commit，这里已经写的很清楚了。现将更改的文件通过add添加到暂存区，然后再使用commit将其提交到（当前分支）版本库。push是推送到远程版本库（也就是Github）。</p>
<blockquote>
<p>图中的HEAD是一个指向master分支(它也是一个指针，这个指针的指向是当前版本)的当前版本的一个指针，稍后介绍分支的时候会解释。</p>
</blockquote>
<h2 id="3-面向修改的Git"><a href="#3-面向修改的Git" class="headerlink" title="3. 面向修改的Git"></a>3. 面向修改的Git</h2><p>Git设计的优点在于它跟踪并记录的是修改而不是文件。</p>
<h3 id="3-1-创建一个Git仓库"><a href="#3-1-创建一个Git仓库" class="headerlink" title="3.1 创建一个Git仓库"></a>3.1 创建一个Git仓库</h3><p>为了接下来的演示，我们创建一个空的Git仓库，cd到目标目录，然后使用命令创建Git仓库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /Users/huanglong/Desktop/GitRepositories/GitTest</span><br><span class="line">$ git init</span><br></pre></td></tr></table></figure></p>
<p>随后会有反馈<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Initialized empty Git repository in /Users/huanglong/Desktop/GitRepositories/GitTest/.git/</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>如果你还没有Git环境请自行搭建</p>
</blockquote>
<p>此时该文件夹中会出现一个.git的隐藏文件夹，这里记录了Git仓库的关键信息，请不要改动它。</p>
<h3 id="3-2-提交文件到暂存区"><a href="#3-2-提交文件到暂存区" class="headerlink" title="3.2 提交文件到暂存区"></a>3.2 提交文件到暂存区</h3><p>首先我们在GitTest文件夹中创建一个新的文件 README.md<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ touch README.md</span><br></pre></td></tr></table></figure></p>
<p>然后往里面放写入东西<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vi README.md</span><br><span class="line">//......写入fsddw</span><br></pre></td></tr></table></figure></p>
<p>然后我们使用如下命令将这个文件加入到我们的暂存区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add README.md</span><br></pre></td></tr></table></figure></p>
<p>然后我们使用这个命令来查看当前Git仓库的状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">	new file:   README.md</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>On branch master 表示我们现在在master分支上 ，分支的概念我们稍后介绍<br>我们可以看到README.md文件已经放入暂存区，但是还没有commit到分支（No commits yet）</p>
</blockquote>
<h3 id="3-3-提交文件到分支"><a href="#3-3-提交文件到分支" class="headerlink" title="3.3 提交文件到分支"></a>3.3 提交文件到分支</h3><p>使用如下命令就可以将缓存区的所有文件提交到分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;test&quot;</span><br><span class="line">[master (root-commit) 0fbdc51] test</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 README.md</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>“ “里打上你对这一次commit的备注，虽然不是必须的，但是推荐每次都打上，方便我们之后回看</p>
</blockquote>
<p>然后我们在查看当前Git仓库的状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure></p>
<p>可以看到工作区是空的(nothing to commit, working tree clean),文件已经全部提交了。</p>
<h3 id="3-4-commit的是修改而不是文件"><a href="#3-4-commit的是修改而不是文件" class="headerlink" title="3.4 commit的是修改而不是文件"></a>3.4 commit的是修改而不是文件</h3><p>为了验证，我们在将README.md放入缓存区后，再对README.md进行修改，然后再commit到分支，你会发现分支并没有应用你的第二次更改。</p>
<h2 id="3-5-撤销修改"><a href="#3-5-撤销修改" class="headerlink" title="3.5 撤销修改"></a>3.5 撤销修改</h2><p>我们此时将README.md中再加入fsqsll。<br>我们发现的这句话是错误的，需要撤销修改，此时应该使用命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- README.md</span><br></pre></td></tr></table></figure></p>
<p>这时候，README就会返回到我们当前版本库中的状态，即只有fsddw。<br>如果你是已经add了修改，然后又对文件进行了修改，那么使用该命令将使你的文件回到add后的状态。如果你已经add了修改，又想让文件回到版本库的状态，那么需要先使用如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD README.md</span><br></pre></td></tr></table></figure></p>
<p>然后再撤销修改。</p>
<h4 id="3-6-文件删除"><a href="#3-6-文件删除" class="headerlink" title="3.6 文件删除"></a>3.6 文件删除</h4><p>如果我们需要将工作区的某个文件删除，可以使用如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git rm README.md</span><br><span class="line">rm &apos;README.md&apos;</span><br><span class="line">$ git commit -m &quot;Delete README.md&quot;</span><br><span class="line">[master 8849efd] Delete README.md</span><br><span class="line"> 1 file changed, 1 deletion(-)</span><br><span class="line"> delete mode 100644 README.md</span><br></pre></td></tr></table></figure></p>
<p>那么当前版本库的这个版本即没有了这个文件。<br>如果你不小心使用了git rm命令删掉了某个文件，但是版本库的当前版本还存在，那么你可以使用如下命令来找回：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- README.md</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>可以看到，checkout同时用于撤销修改和文件找回，因为这个命令实际上就是将版本库的文件复制进入工作区然后覆盖。</p>
</blockquote>
<h2 id="4-Git分支"><a href="#4-Git分支" class="headerlink" title="4. Git分支"></a>4. Git分支</h2><p>Git中最最最强大的功能就是分支了√<br>利用分支结构，不仅可以让开发小组的成员有序地工作，也让我们个人开发项目变得很有条理。</p>
<ul>
<li>你可以让分出多个分支给自己的小组成员，然后各自在一个分支上工作，然后工作完成后再合并到一个分支上</li>
<li>自己一个人的工作同样可以使用分支结构来让自己的项目变得井然有序（master、dev、Feature、Bug分支）<h3 id="4-1-单分支结构"><a href="#4-1-单分支结构" class="headerlink" title="4.1 单分支结构"></a>4.1 单分支结构</h3><blockquote>
<p>这就是我没有学习如何使用Git之前的样子2333333</p>
</blockquote>
</li>
</ul>
<p>以上图中的master分支举例子：<br><img src="https://upload-images.jianshu.io/upload_images/15366117-ff5daf9cb93b7cca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="master分支结构"></p>
<p>master分支是当你创建库时的初始分支，你的每一次更改都会新创建一个圆点，形成一个时间线，HEAD指针自然而然地就指向你现在最新的更改。</p>
<h3 id="4-2-版本退回"><a href="#4-2-版本退回" class="headerlink" title="4.2 版本退回"></a>4.2 版本退回</h3><p>在某些时候，我们可能需要对我们的文件进行版本退回，由于分支的结构特点，利用指针，我们瞬间就可以完成版本的退回，使用如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br></pre></td></tr></table></figure></p>
<p>命令应该很容易理解，HEAD^意思就是HEAD的上一个，其实Git的工作只是将HEAD指向了上一个圆点罢了，所以可以很快的完成。</p>
<blockquote>
<p>上个版本是HEAD^ 上上个是HEAD^^ 以此类推，数量太多的时候就是用HEAD~数量，比如 HEAD~100</p>
</blockquote>
<h3 id="4-3-多分支结构"><a href="#4-3-多分支结构" class="headerlink" title="4.3 多分支结构"></a>4.3 多分支结构</h3><p>不多bb，上图：<img src="https://upload-images.jianshu.io/upload_images/15366117-c5046223017fb52b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="多分支结构"></p>
<p>这里的多分支结构是从4这里看开始分出一个dev的分支，两个分支互不影响，每个分支都可以单独进行操作(其实也就是操作指针)。</p>
<ul>
<li>HEAD：它的指向代表着的是现在正在操作的分支</li>
<li>master/dev：它的指向代表着现在版本库中的版本<h4 id="4-3-1-创建新的分支"><a href="#4-3-1-创建新的分支" class="headerlink" title="4.3.1 创建新的分支"></a>4.3.1 创建新的分支</h4>使用这个命令在当前分支的当前版本创建一个dev分支，并且换到dev分支<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch dev</span><br><span class="line">$ git checkout dev</span><br><span class="line">switched to branch dev</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>以上代码也可以通过这一行代替<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev</span><br><span class="line">switched to a new branch dev</span><br></pre></td></tr></table></figure></p>
<h4 id="4-3-2-合并分支-使用Fast-forward"><a href="#4-3-2-合并分支-使用Fast-forward" class="headerlink" title="4.3.2 合并分支(使用Fast-forward)"></a>4.3.2 合并分支(使用Fast-forward)</h4><p>将两个分支进行合并的操作也很简单，比如我们现在在dev分支上进行完了所有工作，是时候合并到master分支上了，这时我们应首先回到master分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br></pre></td></tr></table></figure></p>
<p>然后将dev分支合并到master中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge dev</span><br></pre></td></tr></table></figure></p>
<p>Tips: 如果你不知道现在在哪个分支，你可以输入如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure></p>
<p>该命令可以列出现在所有的分支，带*号的就是目前所在的分支<br><strong>实战练习：</strong><br>现在我创建一个新的分支，然后在分支上更改了README.md，加入了“守夜冠军不请自来”的字样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev</span><br><span class="line">Switched to a new branch &apos;dev&apos;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://upload-images.jianshu.io/upload_images/15366117-84b6f4384e247683.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在dev分支上更改README"><br>然后add并commit它(略)</p>
<p>随后我们回到master分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &apos;master&apos;</span><br></pre></td></tr></table></figure></p>
<p>此时我们看到README中只有fsddw<br><img src="https://upload-images.jianshu.io/upload_images/15366117-b922fd4a07e127be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="master分支上的README"><br>然后我们开始合并分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git merge dev</span><br><span class="line">Updating 0fbdc51..daecc97</span><br><span class="line">Fast-forward</span><br><span class="line"> README.md | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure></p>
<p>我们再查看一下README，就会发现“守夜冠军不请自来”已经添加到README上了！<br><img src="https://upload-images.jianshu.io/upload_images/15366117-f9dad983ccd7ae1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="master分支合并后已经更改了！"><br>另外通过如下命令可以查看当先的分支图：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* 75edfc5 (HEAD -&gt; master, dev) 守夜冠军不请自来</span><br><span class="line">* 5ff1c9f fsddw</span><br></pre></td></tr></table></figure></p>
<p>如果你不再需要dev分支，那么你可以将它<strong>删掉</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d dev</span><br><span class="line">Deleted branch dev (was daecc97).</span><br></pre></td></tr></table></figure></p>
<ul>
<li>注意，如果你的分支上有未合并的工作，那么Git会提示你再输入一次已确认删除（如果删除这个分支你可能就会丢失你的工作记录）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d dev</span><br><span class="line">error: The branch &apos;dev&apos; is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run &apos;git branch -D dev&apos;.</span><br><span class="line">$ git branch -D dev</span><br><span class="line">Deleted branch dev (was a883195).</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>然后我们再查看当前的分支图：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* 75edfc5 (HEAD -&gt; master) 守夜冠军不请自来</span><br><span class="line">* 5ff1c9f fsddw</span><br></pre></td></tr></table></figure></p>
<p>dev字样被删除了</p>
<h3 id="4-4-分支冲突解决"><a href="#4-4-分支冲突解决" class="headerlink" title="4.4 分支冲突解决"></a>4.4 分支冲突解决</h3><p>上面的实战中，我们从返回的日志可以看到<strong>Fast-forward</strong>的字样<br>表明这个是使用的<strong>快速合并</strong>模式，即直接将master的指针指向dev指针所指向的版本。<img src="https://upload-images.jianshu.io/upload_images/15366117-c8907ae1dfb9c085.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="快速合并"><br>但是，如果我们的master分支同时也对README做出了修改，那么就会出现冲突。<br><strong>实例：</strong><br>现在，我们在master分支上的README加上“守夜冠军不请自来”并add,commit<br>然后我们在这里分出一个新的分支，然后将“守夜冠军不请自来”改成“守夜冠军就是我”，然后add,commit<br>然后回到master分支，再将“守夜冠军不请自来”改成“守夜冠军奖杯是我的”，然后add,commit<br><strong>现在的分支情况如下图：</strong><br><img src="https://upload-images.jianshu.io/upload_images/15366117-04c0f714eb2f1cf5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="现在的分支结构"><br>此时如果我们尝试将他们dev分支合并到master分支上，就会出现错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge dev</span><br><span class="line">Auto-merging README.md</span><br><span class="line">CONFLICT (content): Merge conflict in README.md</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure></p>
<p>这是就会提示合并失败，因为同一个文件两个版本不一致，不知道应该采取谁的版本，Git让我们自己解决冲突，然后我们此时打开README：<br><img src="https://upload-images.jianshu.io/upload_images/15366117-a7ef6a58d105458d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="此时的README"><br>这时合并失败的文件里已经被更改了，而且Git将两个不一样的地方都给我们标了出来，然后我们要做的就是删掉我们不需要的部分。这里我们删掉HEAD的内容。<br><img src="https://upload-images.jianshu.io/upload_images/15366117-fe31f7d9ba34be7c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="删掉冲突的部分"><br>然后重新add,commit即可。</p>
<blockquote>
<p>注意，这里只会提示你合并失败的文件，其他文件是合并成功的，也就是说你自己处理自动合并失败的地方，然后自己重新add,commit</p>
</blockquote>
<p>查看当前的分支图：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   809c050 (HEAD -&gt; master) merge</span><br><span class="line">|\  </span><br><span class="line">| * f533bc3 (dev) test</span><br><span class="line">* | bf15858 test</span><br><span class="line">|/  </span><br><span class="line">* f6f80d2 test</span><br><span class="line">* 24484f1 test</span><br><span class="line">* daecc97 test</span><br><span class="line">* 0fbdc51 test</span><br></pre></td></tr></table></figure></p>
<p>可以看到现在dev分支确实合并到master上了，但是会出现和刚才不一样的分支图<br>这时我们如果删除dev分支的话分支图就会变成这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d dev</span><br><span class="line">Deleted branch dev (was f533bc3).</span><br><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   809c050 (HEAD -&gt; master) merge</span><br><span class="line">|\  </span><br><span class="line">| * f533bc3 test</span><br><span class="line">* | bf15858 test</span><br><span class="line">|/  </span><br><span class="line">* f6f80d2 test </span><br><span class="line">* 24484f1 test</span><br><span class="line">* daecc97 test</span><br><span class="line">* 0fbdc51 test</span><br></pre></td></tr></table></figure></p>
<p>也只是去掉了一个(dev)2333333，因为解决冲突的时候是要创建一个commit来解决</p>
<h3 id="4-5-合并分支-不使用Fast-forward"><a href="#4-5-合并分支-不使用Fast-forward" class="headerlink" title="4.5 合并分支(不使用Fast-forward)"></a>4.5 合并分支(不使用Fast-forward)</h3><p>上面介绍如果使用Fast-forward，会直接将指针指向分支上的版本，这虽然很快，但会有弊端：如果你把被合并的分支删掉后会把历史记录都一并删除。不过，我们可以加入参数来禁止Fast-forward。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --no-ff -m &quot;内容&quot; dev</span><br></pre></td></tr></table></figure></p>
<p><strong>实例：</strong><br>我们重复上面的分支操作进行更改后使用不使用Fast-forwar的合并。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git merge --no-ff -m&quot;使用非Fast-forward合并&quot; dev</span><br><span class="line">Merge made by the &apos;recursive&apos; strategy.</span><br><span class="line"> README.md | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure></p>
<p>然后我们查看分支图：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   aa24518 (HEAD -&gt; master) 使用非Fast-forward合并</span><br><span class="line">|\  </span><br><span class="line">| * 11f4d28 (dev) 守夜冠军不请自来</span><br><span class="line">|/  </span><br><span class="line">* 5ff1c9f fsddw</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到这里多了一个commit，即使我们删除了dev<br>分支，我们仍可以清楚地看到，这里是曾经合并过的。而不是没有任何的提示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d dev</span><br><span class="line">Deleted branch dev (was 11f4d28).</span><br><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   aa24518 (HEAD -&gt; master) 使用非Fast-forward合并</span><br><span class="line">|\  </span><br><span class="line">| * 11f4d28 守夜冠军不请自来</span><br><span class="line">|/  </span><br><span class="line">* 5ff1c9f fsddw</span><br></pre></td></tr></table></figure></p>
<h3 id="4-6-分支策略"><a href="#4-6-分支策略" class="headerlink" title="4.6 分支策略"></a>4.6 分支策略</h3><p>在实际的使用中，分支应该这么设计：</p>
<ul>
<li>master分支应该是最稳定的，工作不应该在master上进行，应该充当一个类似版本更新的分支</li>
<li>dev分支是真正的工作的分支，在这里进行工作</li>
<li>从dev中分出给小组成员的分支，小组成员完成工作后合并到dev分支，dev分支完成一个个小任务后在提交到master分支<br>引用廖雪峰的图：<br><img src="https://upload-images.jianshu.io/upload_images/15366117-67c67d0c374d8caf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="分支策略"></li>
</ul>
<h3 id="4-7-分支的妙用"><a href="#4-7-分支的妙用" class="headerlink" title="4.7 分支的妙用"></a>4.7 分支的妙用</h3><h4 id="4-7-1-Bug分支"><a href="#4-7-1-Bug分支" class="headerlink" title="4.7.1 Bug分支"></a>4.7.1 Bug分支</h4><p>使用Git的分支，我们可以通过创建一个Bug分支，更改bug结束后再合并。但是如果在此时你工作区中还有没有commit的文件，然后但是你又不想马上commit来创建节点，然而这个bug被要求马上完成那可怎么办呢。Git提供了一种储存的方法，将前的工作区保存起来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state WIP on master: aa24518 使用非Fast-forward合并</span><br></pre></td></tr></table></figure></p>
<p>这是我们查看工作区：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure></p>
<p>可以看到工作区是空的了，然后你就可以转换到你要改Bug的分支改Bug<br>改完之后回到原来的分支，并输入如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on master: aa24518 使用非Fast-forward合并</span><br></pre></td></tr></table></figure></p>
<p>看到list，显然我们可以多次保存工作区，这其实很像<strong>快照</strong><br>然后输入下面这个命令来恢复工作区“0”：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash apply stash@&#123;0&#125;</span><br></pre></td></tr></table></figure></p>
<p>和快照一样，恢复快照后并不会删除，你需要手动删除：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash drop stash@&#123;0&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者使用这个命令来恢复并删除：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash pop stash@&#123;0&#125;</span><br></pre></td></tr></table></figure></p>
<p>当list里只有一个stash时，apply/drop/pop可以不接参数，直接应用/删除/应用并删除这个stash</p>
<h2 id="5-使用GitHub进行多人协作"><a href="#5-使用GitHub进行多人协作" class="headerlink" title="5. 使用GitHub进行多人协作"></a>5. 使用GitHub进行多人协作</h2><h3 id="5-1-链接到远程仓库-Github"><a href="#5-1-链接到远程仓库-Github" class="headerlink" title="5.1 链接到远程仓库(Github)"></a>5.1 链接到远程仓库(Github)</h3><p>远程仓库并不只有Githu，这里只是以Github进行举例</p>
<blockquote>
<p>前提: 你的Github已经配置好了公钥</p>
<ul>
<li>首先我们在自己的Github上建立一个仓库(略）</li>
<li>然后我们有两个方法可以让本地的仓库和远程的仓库进行连接</li>
</ul>
<ol>
<li>使用<strong>git clone 你的Git仓库地址</strong><br>这里以自己的仓库举例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/Override0330/AndroidDevelopmentTools.git</span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p>然后等待clone完成，你会发现你终端所在的目录生成了一个AndroidDevelopmentTools文件夹，这个文件夹就是和远程Git仓库链接好的本地仓库√</p>
<ol start="2">
<li>使用<strong>git remote add origin 你的Git仓库地址</strong><br>在你的本地仓库目录中输入如下命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin https://github.com/Override0330/AndroidDevelopmentTools.git</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>origin是远程仓库名(可以自定义，但一般默认）<br>同样可以链接</p>
<h3 id="5-2-将分支推送到Github"><a href="#5-2-将分支推送到Github" class="headerlink" title="5.2 将分支推送到Github"></a>5.2 将分支推送到Github</h3><p>如果你是使用<strong>git clone</strong>的方式建立的链接，在你想要推送的时候使用如下命令就好，但这样默认推送的是master分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push</span><br></pre></td></tr></table></figure></p>
<p>在需要推送到别的远程仓库以及别的分支时，使用如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin dev</span><br></pre></td></tr></table></figure></p>
<p>origin指的是远程仓库名，dev就是你要推送的分支名称</p>
<blockquote>
<p>Tips1:如果你的远程仓库是空的，而且建立链接时使用的是<strong>git remote add origin</strong><br>那么第一次push的时候应该加上参数-u,完整命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;$ git push -u origin dev</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>下一次的时候就不需要加上这个-u参数</p>
</blockquote>
<blockquote>
<p>Tips2:第一次进行提交的时候会提示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;The authenticity of host &apos;github.com (xx.xx.xx.xx)&apos; can&apos;t be established.</span><br><span class="line">&gt;RSA key fingerprint is xx.xx.xx.xx.xx.</span><br><span class="line">&gt;Are you sure you want to continue connecting (yes/no)?</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>这个意思是让你确认公钥是否正确，输入yes按下回车就可以了</p>
</blockquote>
<h3 id="5-3-远程仓库的分支技巧"><a href="#5-3-远程仓库的分支技巧" class="headerlink" title="5.3 远程仓库的分支技巧"></a>5.3 远程仓库的分支技巧</h3><ul>
<li>master是主分支，应该要推送到远程仓库</li>
<li>dev是工作分支，记录着每一次工作，也是应该推送到远程仓库</li>
<li>小组成员工作分支，可以不用推送到远程仓库，只需要从dev分支上分出一个自己的分支，然后在分支上工作，完成工作再合并到dev分支就好了</li>
<li>Bug分支，更没必要除非你想让别人看到你改了什么bug</li>
<li>其他分支，自己开着玩，没必要√<h3 id="5-4-从远程仓库中clone"><a href="#5-4-从远程仓库中clone" class="headerlink" title="5.4 从远程仓库中clone"></a>5.4 从远程仓库中clone</h3>在<strong>5.1 链接到远程仓库</strong>中我们使用了git clone的命令，但是我们clone得到的是这个仓库以及这个仓库的master分支。根据上文<strong>5.3 远程仓库的分支技巧</strong>我们不仅要push到master分支，还要push到dev分支，所以我们需要新建一个和远程仓库分支链接的本地分支：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev origin/dev</span><br><span class="line">//origin代表你的远程仓库名   </span><br><span class="line">//“/”后面接远程仓库的分支名</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>Tips:如果你的远程仓库中并没有dev分支，那么你需要看看<strong>5.5在远程仓库中创建新的分支</strong>不然你会出现报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; The current branch dev has no upstream branch.</span><br><span class="line">&gt; To push the current branch and set the remote as upstream, use</span><br><span class="line">&gt; git push --set-upstream origin dev</span><br><span class="line">&gt; 其实就是多了一个参数罢了</span><br><span class="line">&gt; 然后就可以在dev分支中开始工作啦</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="5-6-在远程仓库中创建新的分支"><a href="#5-6-在远程仓库中创建新的分支" class="headerlink" title="5.6 在远程仓库中创建新的分支"></a>5.6 在远程仓库中创建新的分支</h3><p>在<strong>5.3</strong>的操作中，如果你的仓库没有对应的分支，那么将会报错<br>根据Git的提示，使用如下代码在远程仓库建立新的分支并和本地的dev分支链接在一起:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//记得要先定位到dev分支在进行该操作</span><br><span class="line">$ git push --set-upstream origin dev</span><br><span class="line">Enumerating objects: 5, done.</span><br><span class="line">Counting objects: 100% (5/5), done.</span><br><span class="line">Delta compression using up to 8 threads</span><br><span class="line">Compressing objects: 100% (3/3), done.</span><br><span class="line">Writing objects: 100% (3/3), 401 bytes | 401.00 KiB/s, done.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">remote: </span><br><span class="line">remote: Create a pull request for &apos;dev&apos; on GitHub by visiting:</span><br><span class="line">remote:      https://github.com/Override0330/AndroidDevelopmentTools/pull/new/dev</span><br><span class="line">remote: </span><br><span class="line">To https://github.com/Override0330/AndroidDevelopmentTools.git</span><br><span class="line"> * [new branch]      dev -&gt; dev</span><br><span class="line">Branch &apos;dev&apos; set up to track remote branch &apos;dev&apos; from &apos;origin&apos;.</span><br></pre></td></tr></table></figure></p>
<p>这样就完成了创建分支和链接</p>
<h3 id="5-5-远程仓库的分支合并冲突"><a href="#5-5-远程仓库的分支合并冲突" class="headerlink" title="5.5 远程仓库的分支合并冲突"></a>5.5 远程仓库的分支合并冲突</h3><p>和本地分之合并一样，远程仓库一样会产生分支合并冲突：<br><strong>你push的文件别人同样对他进行了不同的更改而且比你先一步</strong><br>解决方法其实大同小异，根据Git自带的提示，让我们先pull远程的分支到本地，然后在本地进行分支合并，然后在push到远程。<br><strong>实例:</strong><br>假设我有成员A和成员B<br>他们同时通过在master分支新建立一个dev分支<br>成员A将仓库的README修改并且已经提交到远程master分支<br><img src="https://upload-images.jianshu.io/upload_images/15366117-d684b02543b9225c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="成员A的修改"></p>
<p>此时成员B在dev分支也修改完了，也尝试合并到远程master分支<br><img src="https://upload-images.jianshu.io/upload_images/15366117-0b270a989f7b9d6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="成员B的修改"><br>此时就出现了报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git push</span><br><span class="line">To https://github.com/Override0330/AndroidDevelopmentTools.git</span><br><span class="line"> ! [rejected]        master -&gt; master (fetch first)</span><br><span class="line">error: failed to push some refs to &apos;https://github.com/Override0330/AndroidDevelopmentTools.git&apos;</span><br><span class="line">hint: Updates were rejected because the remote contains work that you do</span><br><span class="line">hint: not have locally. This is usually caused by another repository pushing</span><br><span class="line">hint: to the same ref. You may want to first integrate the remote changes</span><br><span class="line">hint: (e.g., &apos;git pull ...&apos;) before pushing again.</span><br><span class="line">hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details.</span><br></pre></td></tr></table></figure></p>
<p>根据提示，我们使用pull进行将当前远程仓库中最新的版本拉取到本地进行手动合并<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">remote: Enumerating objects: 5, done.</span><br><span class="line">remote: Counting objects: 100% (5/5), done.</span><br><span class="line">remote: Compressing objects: 100% (3/3), done.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line">From https://github.com/Override0330/AndroidDevelopmentTools</span><br><span class="line">   4da968a..eb617ad  master     -&gt; origin/master</span><br><span class="line">Auto-merging README.md</span><br><span class="line">CONFLICT (content): Merge conflict in README.md</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure></p>
<p>pull成功了，我们打开README<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim README.md</span><br></pre></td></tr></table></figure></p>
<p><img src="https://upload-images.jianshu.io/upload_images/15366117-18d7027d81d49e2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="pull之后的README"><br>是否似曾相识？和上文中提到的本地冲突一样，手动解决冲突之后，然后重新add，commit就能够完成合并了。<br>这时我们看看分支图如何？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   fd17927 (HEAD -&gt; master, origin/master, origin/HEAD) fix conflict</span><br><span class="line">|\  </span><br><span class="line">| * eb617ad branch conflict test</span><br><span class="line">* | 95194b6 different person branch conflict test</span><br><span class="line">|/  </span><br><span class="line">* 4da968a bug</span><br><span class="line">* 8ba355d update</span><br><span class="line">* 59b308b upload</span><br><span class="line">* f31c620 Initial commit</span><br></pre></td></tr></table></figure></p>
<p>由于我们pull了一次，就会和本地冲突解决一样留下一个commit，现在还挺好，但是当人一多起来，冲突是难免的，冲突解决也都是pull合并冲突重新提交，然后就会变成这个样子：</p>
<blockquote>
<p>由于我一个人模拟多人协作并疯狂pull有点麻烦<br>所以接下来都是引用廖雪峰大佬的示例：<br>原链接：<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0015266568413773c73cdc8b4ab4f9aa9be10ef3078be3f000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0015266568413773c73cdc8b4ab4f9aa9be10ef3078be3f000</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* d1be385 (HEAD -&gt; master, origin/master) init hello</span><br><span class="line">*   e5e69f1 Merge branch &apos;dev&apos;</span><br><span class="line">|\  </span><br><span class="line">| *   57c53ab (origin/dev, dev) fix env conflict</span><br><span class="line">| |\  </span><br><span class="line">| | * 7a5e5dd add env</span><br><span class="line">| * | 7bd91f1 add new env</span><br><span class="line">| |/  </span><br><span class="line">* |   12a631b merged bug fix 101</span><br><span class="line">|\ \  </span><br><span class="line">| * | 4c805e2 fix bug 101</span><br><span class="line">|/ /  </span><br><span class="line">* |   e1e9c68 merge with no-ff</span><br><span class="line">|\ \  </span><br><span class="line">| |/  </span><br><span class="line">| * f52c633 add merge</span><br><span class="line">|/  </span><br><span class="line">*   cf810e4 conflict fixed</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>好乱奥为什么不是一个直线？？？<br>怎么解决这个问题呢？⬇️</p>
<h3 id="5-6-使用Rebase来解决分支太乱的问题"><a href="#5-6-使用Rebase来解决分支太乱的问题" class="headerlink" title="5.6 使用Rebase来解决分支太乱的问题"></a>5.6 使用Rebase来解决分支太乱的问题</h3><p><strong>使用前：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   e0ea545 (HEAD -&gt; master) Merge branch &apos;master&apos; of github.com:michaelliao/learngit</span><br><span class="line">|\  </span><br><span class="line">| * f005ed4 (origin/master) set exit=1</span><br><span class="line">* | 582d922 add author</span><br><span class="line">* | 8875536 add comment</span><br><span class="line">|/  </span><br><span class="line">* d1be385 init hello</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>Tips：这里的时间线貌似出现了一些问题，本地分支超前了远程分支三个commit。</p>
</blockquote>
<p><strong>使用中：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase</span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: add comment</span><br><span class="line">Using index info to reconstruct a base tree...</span><br><span class="line">M    hello.py</span><br><span class="line">Falling back to patching base and 3-way merge...</span><br><span class="line">Auto-merging hello.py</span><br><span class="line">Applying: add author</span><br><span class="line">Using index info to reconstruct a base tree...</span><br><span class="line">M    hello.py</span><br><span class="line">Falling back to patching base and 3-way merge...</span><br><span class="line">Auto-merging hello.py</span><br></pre></td></tr></table></figure></p>
<p><strong>使用后：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* 7e61ed4 (HEAD -&gt; master) add author</span><br><span class="line">* 3611cfe add comment</span><br><span class="line">* f005ed4 (origin/master) set exit=1</span><br><span class="line">* d1be385 init hello</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>有啥用？？？变得好看（实际上我觉得原来也挺好看的）<br>其他的我看不太出来🙃<br>等一手fsddw</p>
<h3 id="5-7-给commit打上标签-tag"><a href="#5-7-给commit打上标签-tag" class="headerlink" title="5.7 给commit打上标签(tag)"></a>5.7 给commit打上标签(tag)</h3><p>标签有啥用？增加可读性√</p>
<h4 id="5-7-1-在本地打标签"><a href="#5-7-1-在本地打标签" class="headerlink" title="5.7.1 在本地打标签"></a>5.7.1 在本地打标签</h4><p>使用如下命令给当前所在分支的最新commit打标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v1.0</span><br></pre></td></tr></table></figure></p>
<p>想给其他commit打标签有点麻烦，在标签名后面加上这个commit的id<br>使用如下命令获得所有commit的id<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline --abbrev-commit</span><br><span class="line">fd17927 (HEAD -&gt; master, tag: v1.0, origin/master, origin/HEAD) fix conflict</span><br><span class="line">95194b6 different person branch conflict test</span><br><span class="line">eb617ad branch conflict test</span><br><span class="line">4da968a bug</span><br><span class="line">293fc4c (origin/dev, dev) dev branch conflict test</span><br><span class="line">383c456 branch conflict test</span><br><span class="line">c20fb65 dev branch test</span><br><span class="line">8ba355d update</span><br><span class="line">59b308b upload</span><br><span class="line">f31c620 Initial commit</span><br></pre></td></tr></table></figure></p>
<p>比如给<strong>95194b6 different person branch conflict test</strong>打标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v0.9 95194b6</span><br></pre></td></tr></table></figure></p>
<p>然后使用这个命令来获得当前分支的所有标签：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v0.9</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure></p>
<p>有创建标签就有删除标签：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d v0.9</span><br><span class="line">Deleted tag &apos;v0.9&apos; (was 95194b6)</span><br></pre></td></tr></table></figure></p>
<p>想要获取某个标签所对应的commit信息？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ git show v1.0</span><br><span class="line">commit fd1792783aabdbb0230d66386def191f9e50beeb (HEAD -&gt; master, tag: v1.0, origin/master, origin/HEAD)</span><br><span class="line">Merge: 95194b6 eb617ad</span><br><span class="line">Author: Override0330 &lt;854098072@qq.com&gt;</span><br><span class="line">Date:   Wed Mar 13 01:41:39 2019 +0800</span><br><span class="line"></span><br><span class="line">    fix conflict</span><br><span class="line"></span><br><span class="line">diff --cc README.md</span><br><span class="line">index 8e5d4a4,6635c26..13c394c</span><br><span class="line">--- a/README.md</span><br><span class="line">+++ b/README.md</span><br><span class="line">@@@ -1,3 -1,3 +1,2 @@@</span><br><span class="line">  # AndroidDevelopmentTools</span><br><span class="line">  这里存放一些自己假装封装的工具类</span><br><span class="line">- 这句话用来测试不同小组成员之间的发生的合并冲突！</span><br><span class="line"> -这里是测试小组成员的合并到master分支上的冲突</span><br></pre></td></tr></table></figure></p>
<p>可以看到记录得非常的清楚√</p>
<h4 id="5-7-2-在远程仓库打标签"><a href="#5-7-2-在远程仓库打标签" class="headerlink" title="5.7.2 在远程仓库打标签"></a>5.7.2 在远程仓库打标签</h4><p>和提交修改差不多，只需要将标签push到远程仓库就可以了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin v1.0</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To https://github.com/Override0330/AndroidDevelopmentTools.git</span><br><span class="line"> * [new tag]         v1.0 -&gt; v1.0</span><br></pre></td></tr></table></figure></p>
<p>或者一次性添加所有标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin --tags</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To https://github.com/Override0330/AndroidDevelopmentTools.git</span><br><span class="line"> * [new tag]         v0.9 -&gt; v0.9</span><br></pre></td></tr></table></figure></p>
<p>然后我们在Github上就可以通过tags来筛选commit了<br><img src="https://upload-images.jianshu.io/upload_images/15366117-ced13c88a366b0a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Github上的tag"><br>删除远程标签，先在本地删除，然后再push到远程，注意push的格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d v0.9</span><br><span class="line">Deleted tag &apos;v0.9&apos; (was 95194b6)</span><br><span class="line"></span><br><span class="line">$ git push origin :refs/tags/v0.9</span><br><span class="line">To https://github.com/Override0330/AndroidDevelopmentTools.git</span><br><span class="line"> - [deleted]         v0.9</span><br></pre></td></tr></table></figure></p>
<h2 id="6-小结"><a href="#6-小结" class="headerlink" title="6. 小结"></a>6. 小结</h2><p>这篇学习笔记可以说是我写过最长的了2333333可能内容比较多吧问题不大，加深了很大的印象。<br>然后接下来时常用命令汇总：<br><strong>Git仓库管理：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//创建一个空仓库</span><br><span class="line">$ git init</span><br><span class="line">//添加指定文件/所有文件到暂存区</span><br><span class="line">$ git add &lt;filename&gt;/.</span><br><span class="line">//将工作区的文件提交到分支</span><br><span class="line">$ git commit -m &quot;info&quot;</span><br><span class="line">//查看当前Git仓库状态</span><br><span class="line">$ git status</span><br><span class="line">//撤销指定文件的修改/删除</span><br><span class="line">$ git checkout -- &lt;filename&gt;</span><br><span class="line">$ git reset HEAD &lt;filename&gt;</span><br><span class="line">//删除工作区的文件</span><br><span class="line">$ git rm &lt;filename&gt;</span><br><span class="line">//给当前工作区的文件“拍快照”</span><br><span class="line">$ git stash</span><br><span class="line">//查看“快照列表”</span><br><span class="line">$ git stash list</span><br><span class="line">//恢复快照</span><br><span class="line">$ git stash apply &lt;stashId&gt;</span><br><span class="line">//删除快照</span><br><span class="line">$ git stash drop &lt;stashId&gt;</span><br><span class="line">//恢复并删除快照</span><br><span class="line">$ git stash pop &lt;stashId&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>Git分支:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//创建分支</span><br><span class="line">$ git branch &lt;branchName&gt;</span><br><span class="line">//切换到分支</span><br><span class="line">$ git checkout &lt;branchName&gt;</span><br><span class="line">//创建并切换到分支</span><br><span class="line">$ git checkout -b &lt;branchName&gt;</span><br><span class="line">//删除分支</span><br><span class="line">$ git branch -d &lt;branchName&gt;</span><br><span class="line">//查看分支列表</span><br><span class="line">$ git branch</span><br><span class="line">//版本退回</span><br><span class="line">$ git reset --hard HEAD^</span><br><span class="line">//将目标分支合并到当前分支默认使用Fast-forward</span><br><span class="line">$ git merge &lt;branchName&gt;</span><br><span class="line">//将目标分支合并到当前分支不使用Fast-forward</span><br><span class="line">$ git merge --no-ff -m &quot;info&quot; &lt;branchName&gt;</span><br><span class="line">//查看分支图</span><br><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br></pre></td></tr></table></figure></p>
<p><strong>远程仓库：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//克隆目标Git仓库</span><br><span class="line">$ git clone &lt;HttpsUrl/ssh&gt;</span><br><span class="line">//将当前的Git仓库和远程仓库链接</span><br><span class="line">$ git remote add &lt;远程仓库名称&gt; &lt;HttpsUrl/ssh&gt;</span><br><span class="line">//将当前分支推送到远程仓库</span><br><span class="line">$ git push</span><br><span class="line">$ git push &lt;远程仓库名&gt; &lt;branchName&gt;</span><br><span class="line">$ git push -u &lt;远程仓库名&gt; &lt;branchName&gt;</span><br><span class="line">//新建本地分支和并和远程仓库的对应分支连接</span><br><span class="line">$ git checkout -b &lt;本地分支名&gt; &lt;远程仓库名&gt;/&lt;远程分支名&gt;</span><br><span class="line">//在远程仓库中新建新的分支并和当前的本地分支相连接</span><br><span class="line">$ git push --set-upstream &lt;远程仓库名&gt; &lt;新建的远程分支名&gt;</span><br><span class="line">//解决合并冲突</span><br><span class="line">$ git pull</span><br><span class="line">//让分支图变得整洁好看</span><br><span class="line">$ git rebase</span><br></pre></td></tr></table></figure></p>
<p><strong>标签使用：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//给当前branch的最新commit加标签</span><br><span class="line">$ git tag &lt;tag&gt;</span><br><span class="line">//给之前的commit加标签</span><br><span class="line">$ git tag &lt;tag&gt; &lt;commitId&gt;</span><br><span class="line">//显示当前分支所有commit的id</span><br><span class="line">$ git log --pretty=oneline --abbrev-commit</span><br><span class="line">//显示该分支下的所有标签</span><br><span class="line">$ git tag</span><br><span class="line">//删除标签</span><br><span class="line">$ git tag -d &lt;tag&gt;</span><br><span class="line">//获取某个标签所对应的commit的详细信息</span><br><span class="line">$ git show &lt;tag&gt;</span><br><span class="line">//将标签推送到远程仓库</span><br><span class="line">$ git push &lt;远程仓库名&gt; &lt;tag&gt;</span><br><span class="line">$ git push &lt;远程仓库名&gt; --tags</span><br><span class="line">//删除远程标签，请先在本地删除</span><br><span class="line">$ git push &lt;远程仓库名&gt; :refs/tags/&lt;tag&gt;</span><br></pre></td></tr></table></figure></p>
</article><!-- lincense--><div class="license-wrapper"><p> <span>Author:  </span><a href="Override0330.github.io">Override</a></p><p> <span>Link:  </span><a href="Override0330.github.io/2019/03/13/git/">Override0330.github.io/2019/03/13/git/</a></p><p> <span>Copyright:  </span><span>All articles in this blog are licensed under <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/3.0">CC BY-NC-SA 3.0</a> unless stating additionally.</span></p></div><div class="post-paginator"><a class="prevSlogan" href="/2019/03/31/jihe/" title="Java-集合的简单介绍"><span>< PreviousPost</span><br><span class="prevTitle">Java-集合的简单介绍</span></a><a class="nextSlogan" href="/2019/03/12/ThreadPool/" title="java中的四种线程池"><span>NextPost ></span><br><span class="nextTitle">java中的四种线程池</span></a><div class="clear"></div></div><div id="comment"></div></section></article><footer id="cxo-footer-outer"><div id="cxo-footer-inner"><p class="footer-container"><span>Site by </span><a href="http://hexo.io"><span>Hexo</span></a><span> | theme </span><a href="https://github.com/Longlongyu/hexo-theme-Cxo"><span>Cxo</span></a></p><i class="fa fa-user"> </i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"> </i><span id="busuanzi_value_site_pv"></span></div></footer><!-- catelog--><div class="toc-wrapper" style="top: 70vh;"><div class="toc-catalog"><i class="fa fa-list"> </i><span>CATALOG</span></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Git的由来"><span class="toc-number">1.</span> <span class="toc-text">1. Git的由来</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Git的结构"><span class="toc-number">2.</span> <span class="toc-text">2. Git的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-分布式"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 分布式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-仓库结构"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 仓库结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-工作区"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.2.1 工作区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-代码库"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2.2 代码库</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-面向修改的Git"><span class="toc-number">3.</span> <span class="toc-text">3. 面向修改的Git</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-创建一个Git仓库"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 创建一个Git仓库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-提交文件到暂存区"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 提交文件到暂存区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-提交文件到分支"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 提交文件到分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-commit的是修改而不是文件"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 commit的是修改而不是文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-撤销修改"><span class="toc-number">4.</span> <span class="toc-text">3.5 撤销修改</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-文件删除"><span class="toc-number">4.0.1.</span> <span class="toc-text">3.6 文件删除</span></a></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Git分支"><span class="toc-number">5.</span> <span class="toc-text">4. Git分支</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-单分支结构"><span class="toc-number">5.1.</span> <span class="toc-text">4.1 单分支结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-版本退回"><span class="toc-number">5.2.</span> <span class="toc-text">4.2 版本退回</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-多分支结构"><span class="toc-number">5.3.</span> <span class="toc-text">4.3 多分支结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1-创建新的分支"><span class="toc-number">5.3.1.</span> <span class="toc-text">4.3.1 创建新的分支</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2-合并分支-使用Fast-forward"><span class="toc-number">5.3.2.</span> <span class="toc-text">4.3.2 合并分支(使用Fast-forward)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-分支冲突解决"><span class="toc-number">5.4.</span> <span class="toc-text">4.4 分支冲突解决</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-合并分支-不使用Fast-forward"><span class="toc-number">5.5.</span> <span class="toc-text">4.5 合并分支(不使用Fast-forward)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-分支策略"><span class="toc-number">5.6.</span> <span class="toc-text">4.6 分支策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-分支的妙用"><span class="toc-number">5.7.</span> <span class="toc-text">4.7 分支的妙用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-7-1-Bug分支"><span class="toc-number">5.7.1.</span> <span class="toc-text">4.7.1 Bug分支</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-使用GitHub进行多人协作"><span class="toc-number">6.</span> <span class="toc-text">5. 使用GitHub进行多人协作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-链接到远程仓库-Github"><span class="toc-number">6.1.</span> <span class="toc-text">5.1 链接到远程仓库(Github)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-将分支推送到Github"><span class="toc-number">6.2.</span> <span class="toc-text">5.2 将分支推送到Github</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-远程仓库的分支技巧"><span class="toc-number">6.3.</span> <span class="toc-text">5.3 远程仓库的分支技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-从远程仓库中clone"><span class="toc-number">6.4.</span> <span class="toc-text">5.4 从远程仓库中clone</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-在远程仓库中创建新的分支"><span class="toc-number">6.5.</span> <span class="toc-text">5.6 在远程仓库中创建新的分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-远程仓库的分支合并冲突"><span class="toc-number">6.6.</span> <span class="toc-text">5.5 远程仓库的分支合并冲突</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-使用Rebase来解决分支太乱的问题"><span class="toc-number">6.7.</span> <span class="toc-text">5.6 使用Rebase来解决分支太乱的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-给commit打上标签-tag"><span class="toc-number">6.8.</span> <span class="toc-text">5.7 给commit打上标签(tag)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7-1-在本地打标签"><span class="toc-number">6.8.1.</span> <span class="toc-text">5.7.1 在本地打标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7-2-在远程仓库打标签"><span class="toc-number">6.8.2.</span> <span class="toc-text">5.7.2 在远程仓库打标签</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-小结"><span class="toc-number">7.</span> <span class="toc-text">6. 小结</span></a></li></div><!-- top--><i class="fa fa-arrow-up close" id="go-up" aria-hidden="true"></i></body></html>